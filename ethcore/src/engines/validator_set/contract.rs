// Copyright 2015, 2016 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

/// Validator set maintained in a contract.

use std::sync::Weak;
use util::*;
use client::{Client, BlockChainClient};
use client::chain_notify::ChainNotify;
use super::ValidatorSet;
use super::simple_list::SimpleList;

pub struct ValidatorContract {
	address: Address,
	validators: RwLock<SimpleList>,
	provider: RwLock<Option<provider::Contract>>,
}

impl ValidatorContract {
	pub fn new(contract_address: Address) -> Self {
		ValidatorContract {
			address: contract_address,
			validators: Default::default(),
			provider: RwLock::new(None),
		}
	}
}

impl ChainNotify for ValidatorContract {
	fn new_blocks(
		&self,
		_imported: Vec<H256>,
		_: Vec<H256>,
		_: Vec<H256>,
		_: Vec<H256>,
		_: Vec<H256>,
		_duration: u64) {
		if let Some(ref provider) = *self.provider.read() {
			match provider.get_validators() {
				Ok(new) => {
					debug!(target: "engine", "Set of validators obtained: {:?}", new);
					*self.validators.write() = SimpleList::new(new);
				},
				Err(s) => warn!("Set of validators could not be updated: {}", s),
			}
		} else {
			warn!("Set of validators could not be updated: no provider contract.")
		}
	}
}

impl ValidatorSet for ValidatorContract {
	fn contains(&self, address: &Address) -> bool {
		self.validators.read().contains(address)
	}

	fn get(&self, nonce: usize) -> Address {
		self.validators.read().get(nonce).clone()
	}

	fn register_call_contract(&self, client: Weak<Client>) {
		*self.provider.write() = Some(provider::Contract::new(self.address, move |a, d| client.upgrade().ok_or("No client!".into()).and_then(|c| c.call_contract(a, d))));
	}
}

mod provider {
// Autogenerated from JSON contract definition using Rust contract convertor.

#![allow(unused_imports)]
use std::string::String;
use std::result::Result;
use std::fmt;
use {util, ethabi};
use util::{FixedHash, Uint};

pub struct Contract {
	contract: ethabi::Contract,
	address: util::Address,
	do_call: Box<Fn(util::Address, Vec<u8>) -> Result<Vec<u8>, String> + Send + Sync + 'static>,
}
impl Contract {
	pub fn new<F>(address: util::Address, do_call: F) -> Self where F: Fn(util::Address, Vec<u8>) -> Result<Vec<u8>, String> + Send + Sync + 'static {
		Contract {
			contract: ethabi::Contract::new(ethabi::Interface::load(b"[{\"constant\":true,\"inputs\":[],\"name\":\"get_validators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"}]").expect("JSON is autogenerated; qed")),
			address: address,
			do_call: Box::new(do_call),
		}
	}
	fn as_string<T: fmt::Debug>(e: T) -> String { format!("{:?}", e) }
	
	/// Auto-generated from: `{"constant":true,"inputs":[],"name":"get_validators","outputs":[{"name":"","type":"address[]"}],"payable":false,"type":"function"}`
	#[allow(dead_code)]
	pub fn get_validators(&self) -> Result<Vec<util::Address>, String> { 
		let call = self.contract.function("get_validators".into()).map_err(Self::as_string)?;
		let data = call.encode_call(
			vec![]
		).map_err(Self::as_string)?;
		let output = call.decode_output((self.do_call)(self.address.clone(), data)?).map_err(Self::as_string)?;
		let mut result = output.into_iter().rev().collect::<Vec<_>>();
		Ok(({ let r = result.pop().ok_or("Invalid return arity")?; let r = try!(r.to_array().and_then(|v| v.into_iter().map(|a| a.to_address()).collect::<Option<Vec<[u8; 20]>>>()).ok_or("Invalid type returned")); r.into_iter().map(|a| util::Address::from(a)).collect::<Vec<_>>() })) 
	}
}


}
